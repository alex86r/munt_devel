diff -Nru dosbox-0.74/src/Makefile.am dosbox-0.74-mt32/src/Makefile.am
--- dosbox-0.74/src/Makefile.am	2010-05-10 17:43:54 +0000
+++ dosbox-0.74-mt32/src/Makefile.am	2011-04-17 18:06:01 +0000
@@ -17,4 +17,4 @@
 
 EXTRA_DIST = winres.rc dosbox.ico
 
-
+LIBS +=  -lmt32emu
diff -Nru dosbox-0.74/src/dosbox.cpp dosbox-0.74-mt32/src/dosbox.cpp
--- dosbox-0.74/src/dosbox.cpp	2010-05-10 17:43:54 +0000
+++ dosbox-0.74-mt32/src/dosbox.cpp	2011-04-29 13:35:39 +0000
@@ -467,7 +467,7 @@
 	
 	const char* mputypes[] = { "intelligent", "uart", "none",0};
 	// FIXME: add some way to offer the actually available choices.
-	const char *devices[] = { "default", "win32", "alsa", "oss", "coreaudio", "coremidi","none", 0};
+	const char *devices[] = { "default", "win32", "alsa", "oss", "coreaudio", "coremidi", "mt32", "none", 0};
 	Pstring = secprop->Add_string("mpu401",Property::Changeable::WhenIdle,"intelligent");
 	Pstring->Set_values(mputypes);
 	Pstring->Set_help("Type of MPU-401 to emulate.");
@@ -480,6 +480,21 @@
 	Pstring->Set_help("Special configuration options for the device driver. This is usually the id of the device you want to use.\n"
 	                  "  See the README/Manual for more details.");
 
+	const char *mt32reverbModes[] = {"0", "1", "2", "3", "auto",0};
+	Pstring = secprop->Add_string("mt32reverb.mode",Property::Changeable::WhenIdle,"auto");
+	Pstring->Set_values(mt32reverbModes);
+	Pstring->Set_help("MT-32 reverb mode");
+
+	const char *mt32reverbTimes[] = {"0", "1", "2", "3", "4", "5", "6", "7",0};
+	Pint = secprop->Add_int("mt32reverb.time",Property::Changeable::WhenIdle,5);
+	Pint->Set_values(mt32reverbTimes);
+	Pint->Set_help("MT-32 reverb time"); 
+
+	const char *mt32reverbLevels[] = {"0", "1", "2", "3", "4", "5", "6", "7",0};
+	Pint = secprop->Add_int("mt32reverb.level",Property::Changeable::WhenIdle,3);
+	Pint->Set_values(mt32reverbLevels);
+	Pint->Set_help("MT-32 reverb level");
+
 #if C_DEBUG
 	secprop=control->AddSection_prop("debug",&DEBUG_Init);
 #endif
diff -Nru dosbox-0.74/src/gui/Makefile.am dosbox-0.74-mt32/src/gui/Makefile.am
--- dosbox-0.74/src/gui/Makefile.am	2010-05-10 17:43:54 +0000
+++ dosbox-0.74-mt32/src/gui/Makefile.am	2011-04-17 18:06:19 +0000
@@ -7,5 +7,5 @@
 	render_templates_sai.h render_templates_hq.h \
 	render_templates_hq2x.h render_templates_hq3x.h \
 	midi.cpp midi_win32.h midi_oss.h midi_coreaudio.h midi_alsa.h \
-	midi_coremidi.h sdl_gui.cpp dosbox_splash.h
+	midi_coremidi.h midi_mt32.h sdl_gui.cpp dosbox_splash.h
 
diff -Nru dosbox-0.74/src/gui/midi.cpp dosbox-0.74-mt32/src/gui/midi.cpp
--- dosbox-0.74/src/gui/midi.cpp	2010-05-10 17:43:54 +0000
+++ dosbox-0.74-mt32/src/gui/midi.cpp	2011-04-17 18:06:28 +0000
@@ -98,6 +98,8 @@
 
 #endif
 
+#include "midi_mt32.h"
+
 static struct {
 	Bitu status;
 	Bitu cmd_len;
diff -Nru dosbox-0.74/src/gui/midi_mt32.h dosbox-0.74-mt32/src/gui/midi_mt32.h
--- dosbox-0.74/src/gui/midi_mt32.h	1970-01-01 00:00:00 +0000
+++ dosbox-0.74-mt32/src/gui/midi_mt32.h	2011-04-29 16:38:18 +0000
@@ -0,0 +1,274 @@
+#include "mt32emu.h"
+#include "mixer.h"
+#include "control.h"
+#include <SDL_Thread.h>
+
+#include <iostream> 
+#include <string>  
+
+using namespace std;   
+
+#ifdef MT32MULTICORE
+static inline void cpuID(unsigned i, unsigned regs[4]) { 
+   __asm__ __volatile__
+   ("cpuid" : "=a" (regs[0]), "=b" (regs[1]), "=c" (regs[2]), "=d" (regs[3]): "a" (i), "c" (0));
+   // ECX is set to zero for CPUID function 4
+}  
+
+static inline int cpu_check(void) {
+    unsigned regs[4]; 
+    char vendor[12];
+    cpuID(0, regs);
+    ((unsigned *)vendor)[0] = regs[1]; // EBX
+    ((unsigned *)vendor)[1] = regs[3]; // EDX
+    ((unsigned *)vendor)[2] = regs[2]; // ECX
+    string cpuVendor = string(vendor, 12); 
+
+    // Get CPU features
+    cpuID(1, regs);
+    unsigned cpuFeatures = regs[3]; // EDX 
+    if (cpuVendor == "GenuineIntel" && cpuFeatures & (1 << 28)) { // HTT bit
+        // Logical core count per CPU
+        cpuID(1, regs);     unsigned logical = (regs[1] >> 16) & 0xff; // EBX[23:16]
+        unsigned cores = logical;
+
+        if (cpuVendor == "GenuineIntel") {
+           // Get DCP cache info
+           cpuID(4, regs);
+           cores = ((regs[0] >> 26) & 0x3f) + 1; // EAX[31:26] + 1
+        } else if (cpuVendor == "AuthenticAMD") {
+           // Get NC: Number of CPU cores - 1
+           cpuID(0x80000008, regs);
+           cores = ((unsigned)(regs[2] & 0xff)) + 1; // ECX[7:0] + 1
+        } else return 1;
+        return cores;
+   }
+   return 0;
+}
+#endif
+
+MT32Emu::Synth *_usesynth;
+MixerChannel *mt32chan = NULL;
+
+static struct {
+#ifdef MT32MULTICORE
+	SDL_mutex * mutex;
+	SDL_semaphore * sem;
+	SDL_Thread * thread;
+    bool multicore;
+#endif
+	volatile bool running, busy;
+
+	Bit8u len, play;
+	Bit8u Temp[MIXER_BUFSIZE], msg[SYSEX_SIZE];
+} mt32;
+
+#ifdef MT32MULTICORE
+static int MT32_Thread(void*) {
+	SDL_LockMutex(mt32.mutex);
+
+	while(mt32.running) {
+
+		Bitu len;
+		if(!(mt32.play) && !(mt32.len)) {
+			SDL_UnlockMutex(mt32.mutex);
+			SDL_SemWait(mt32.sem);
+			SDL_LockMutex(mt32.mutex);
+		}
+
+		mt32.busy = true;
+		while(mt32.play) {
+			len = mt32.play;
+			Bit32u *tmp = ((Bit32u*)mt32.msg);
+			SDL_UnlockMutex(mt32.mutex);
+
+			while(len--) {
+				_usesynth->playMsg(*tmp++);
+			}
+
+			SDL_LockMutex(mt32.mutex);
+			len = tmp-(Bit32u*)mt32.msg;
+			mt32.play -= len;
+			if(mt32.play) SDL_memmove(mt32.msg, tmp, mt32.play<<2);
+		}
+
+		while(mt32.len) {
+			len = (mt32.len>>2) < MIXER_BUFSIZE ? mt32.len : MIXER_BUFSIZE<<2;
+			mt32.len -= len;
+
+#ifdef MT32DEBUG
+			if(mt32.len) LOG_MSG("MT32:WARNING: len left (%d)", mt32.len);
+#endif
+
+			SDL_UnlockMutex(mt32.mutex);
+			_usesynth->render((Bit16s *)mt32.Temp, len);
+			mt32chan->AddSamples_s16(len,(Bit16s *)mt32.Temp);
+			SDL_LockMutex(mt32.mutex);
+			break;
+		}
+		mt32.busy = false;
+	}
+
+	SDL_UnlockMutex(mt32.mutex);
+	return 0;
+}
+#endif
+
+static void MT32_CallBack(Bitu len) {
+#ifdef MT32MULTICORE
+    if(mt32.multicore) {
+    	SDL_LockMutex(mt32.mutex);
+    	mt32.len += len;
+    	SDL_UnlockMutex(mt32.mutex);
+    	SDL_SemPost(mt32.sem);
+    } else {
+#endif
+       _usesynth->render((Bit16s *)MixTemp, len);
+       mt32chan->AddSamples_s16(len,(Bit16s *)MixTemp);
+#ifdef MT32MULTICORE
+    }
+#endif
+}
+
+static int report(void *userData, MT32Emu::ReportType type, const void *reportData) {
+   switch(type) {
+   case MT32Emu::ReportType_errorControlROM:
+      LOG_MSG("MT32:Couldn't find control files");
+      break;
+   case MT32Emu::ReportType_errorPCMROM:
+      LOG_MSG("MT32:Couldn't open MT32_PCM.ROM file");
+      break;
+   default:
+      //LOG(LOG_ALL,LOG_NORMAL)("MT32: Report %d",type);
+      break;
+   }
+   return 0;
+}
+
+class MidiHandler_mt32: public MidiHandler {
+private:
+   MT32Emu::Synth *_synth;
+   int _outputRate;
+   bool isOpen;
+
+public:
+   MidiHandler_mt32() : isOpen(false),MidiHandler() {};
+   const char * GetName(void) { return "mt32";};
+   bool Open(const char * conf) {
+      MT32Emu::SynthProperties tmpProp;
+      memset(&tmpProp, 0, sizeof(tmpProp));
+      tmpProp.sampleRate = 32000;
+
+      tmpProp.useDefaultReverb = false;
+      tmpProp.useReverb = true;
+      tmpProp.reverbType = 0;
+      tmpProp.reverbTime = 5;
+      tmpProp.reverbLevel = 3;
+      tmpProp.userData = this;
+      //tmpProp.printDebug = &vdebug;
+      tmpProp.report = &report;
+      _synth = new MT32Emu::Synth();
+      if (_synth->open(tmpProp)==0) {
+         LOG(LOG_ALL,LOG_ERROR)("MT32:Error initialising emulation");
+         return false;
+      }
+      _usesynth=_synth;
+
+			Section_prop* section=static_cast<Section_prop *>(control->GetSection("midi"));
+      if(strcmp(section->Get_string("mt32reverb.mode"),"auto")) {
+					Bit8u reverbsysex[] = {0x10, 0x00, 0x01, 0x00, 0x05, 0x03};
+					reverbsysex[3] = (Bit8u)atoi(section->Get_string("mt32reverb.mode"));
+					reverbsysex[4] = (Bit8u)section->Get_int("mt32reverb.time");
+					reverbsysex[5] = (Bit8u)section->Get_int("mt32reverb.level");
+					_synth->writeSysex(16, reverbsysex, 6);
+					_synth->setReverbOverridden(true);
+      } else {
+		      LOG_MSG("MT32: Using default reverb");
+      }
+
+			if (mt32chan == NULL)
+          mt32chan=MIXER_AddChannel(MT32_CallBack,tmpProp.sampleRate,"MT32");
+
+      mt32chan->Enable(true);
+
+      /* Create MT32 thread */
+#ifdef MT32MULTICORE
+      mt32.multicore=(cpu_check()>1?true:false);
+      if(mt32.multicore) {
+          mt32.mutex = SDL_CreateMutex();
+          mt32.sem = SDL_CreateSemaphore(0);
+          mt32.running = true;
+          mt32.busy = false;
+          mt32.play = 0;
+          mt32.thread = SDL_CreateThread(MT32_Thread, NULL);
+      }
+#endif
+      return true;
+   };
+
+	 void Close(void) {
+      if (!isOpen) return;
+      mt32chan->Enable(false);
+#ifdef MT32MULTICORE
+      if(mt32.multicore) {
+          mt32.running = false;
+          SDL_SemPost(mt32.sem);
+          SDL_WaitThread(mt32.thread, NULL);
+          SDL_DestroyMutex(mt32.mutex);
+      }
+#endif
+      _synth->close();
+      delete _synth;
+      _synth = NULL;
+      _usesynth=_synth;
+      isOpen=false;
+   };
+
+	 void PlayMsg(Bit8u * msg) {
+#ifdef MT32MULTICORE
+      if(mt32.multicore) {
+          // Try to queue play commands
+          SDL_LockMutex(mt32.mutex);
+          // Playcommand buffer full?
+          while(!(mt32.play < SYSEX_SIZE>>2)) {
+            SDL_UnlockMutex(mt32.mutex);
+            LOG_MSG("MT32:Playback buffer full...");
+            SDL_LockMutex(mt32.mutex);
+          }
+          SDL_memcpy(mt32.msg+(mt32.play<<2), msg, sizeof(Bit32u));
+          mt32.play ++;
+          SDL_UnlockMutex(mt32.mutex);
+          SDL_SemPost(mt32.sem);
+     } else {
+#endif
+          _synth->playMsg(*((Bit32u*) msg));
+#ifdef MT32MULTICORE
+     }
+#endif
+   };
+
+	 void PlaySysex(Bit8u * sysex,Bitu len) {
+#ifdef MT32MULTICORE
+      if(mt32.multicore) {
+          SDL_LockMutex(mt32.mutex);
+          while(mt32.busy) {
+            SDL_UnlockMutex(mt32.mutex);
+#ifdef MT32DEBUG
+            LOG_MSG("MT32:Waiting to deliver sysex");
+#endif
+            SDL_LockMutex(mt32.mutex);
+          }
+      }
+#endif
+      if(sysex[0] == 0xf0) {
+         _synth->playSysex(sysex, len);
+      } else {
+         _synth->playSysexWithoutFraming(sysex, len);
+      }
+#ifdef MT32MULTICORE
+      if(mt32.multicore) SDL_UnlockMutex(mt32.mutex);
+#endif
+   };
+};
+
+MidiHandler_mt32 Midi_mt32;
